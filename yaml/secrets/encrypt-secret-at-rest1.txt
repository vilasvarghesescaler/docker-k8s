1. Why Encrypt etcd?

	By default, Kubernetes stores secrets base64-encoded, not encrypted, in etcd.

	Anyone with access to etcd (or a backup) can read them.

	Enabling encryption ensures secrets and sensitive resources are encrypted at rest.

2. How Encryption Works

	Kubernetes API server handles encryption before writing to etcd and decrypts when reading.

	Uses an encryption configuration file (EncryptionConfiguration).

	Multiple providers supported:

	aescbc (recommended)

	kms (for cloud-managed keys, e.g., AWS KMS, GCP KMS, Azure Key Vault)

	secretbox

	identity (no encryption)

3. Steps to Enable etcd Encryption
	Step 1: Create an Encryption Configuration File

	On the control-plane node, create /etc/kubernetes/encryption-config.yaml:

apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
      - configmaps
      - deployments
      - services
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: <BASE64-ENCODED-32-BYTE-KEY>
      - identity: {}


Generate a 32-byte key:

head -c 32 /dev/urandom | base64


Replace <BASE64-ENCODED-32-BYTE-KEY> with the output.

Step 2: Edit API Server Manifest

Edit the kube-apiserver manifest (for kubeadm: /etc/kubernetes/manifests/kube-apiserver.yaml):

Add:

--encryption-provider-config=/etc/kubernetes/encryption-config.yaml


Save & exit â€” kubelet will restart the kube-apiserver.

Step 3: Verify Encryption

Create a secret:

kubectl create secret generic test-secret \
  --from-literal=password=SuperSecret123


Read secret via API (should be plaintext):

kubectl get secret test-secret -o yaml


Check raw etcd data (should be encrypted):

ETCDCTL_API=3 etcdctl get \
  /kubernetes.io/secrets/default/test-secret \
  --endpoints=https://127.0.0.1:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key | hexdump -C


ðŸ‘‰ Output will show gibberish ciphertext instead of base64 plaintext.

Step 4: Re-encrypt Existing Data

New secrets are encrypted automatically, but old ones remain in plaintext until rewritten.

To re-encrypt all:

kubectl get secrets --all-namespaces -o json | kubectl replace -f -


Or use:

kubectl get secrets --all-namespaces -o yaml | kubectl apply -f -


This forces the API server to re-write them, now using encryption.

4. Using Cloud KMS (Optional, More Secure)

Instead of storing keys locally, use a KMS provider. Example (AWS KMS):

apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - kms:
          name: awskms
          endpoint: unix:///var/run/kmsplugin/socket.sock
          cachesize: 1000
          timeout: 3s
      - identity: {}


Youâ€™ll need to run a KMS plugin container that talks to AWS/GCP/Azure KMS.

5. Best Practices

âœ… Always use aescbc or KMS (not secretbox in prod).
âœ… Rotate encryption keys periodically:

Add a new key (key2) to config.

Move it above old key (key1) to make it primary.

Re-encrypt data.

Remove old key.
âœ… Restrict access to etcd (network + filesystem).
âœ… Always back up the encryption config file + keys safely (without it, you canâ€™t decrypt).

âš¡ Quick recap:

Create encryption config file.

Configure kube-apiserver.

Verify secret is encrypted in etcd.

Re-encrypt existing secrets.

Rotate keys periodically.